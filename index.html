<body class="p-4 md:p-6">
    <div class="cursor"></div>
    <div class="cursor-follower"></div>
    
    <div class="loader">
        <div class="loader-text">INITIALIZING...</div>
    </div>
    
    <div class="noise-bg"></div>
    
    <div id="particles-container"></div>

    <main class="max-w-6xl mx-auto">
        <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-6 gap-4 md:gap-6">
            
            <div class="bento-item min-h-[350px] md:min-h-[400px] md:col-span-2 lg:col-span-4 lg:row-span-2 flex flex-col justify-between scroll-animate">
                <div class="relative z-10 p-4 md:p-6">
                    <h1 class="text-5xl sm:text-6xl md:text-7xl lg:text-8xl xl:text-9xl y2k-glow accent-color" data-text="appuzlota">appuzlota</h1>
                    <p class="text-base sm:text-lg md:text-xl lg:text-2xl mt-2 text-gray-300 typewriter">Developer & Aspiring Entrepreneur</p>
                </div>
                <div class="relative z-10 text-gray-400 text-sm p-4 md:p-6">
                    <p class="status-line">Status: <span class="accent-color blink">Online</span></p>
                    <p class="location-line">Location: The Digital Frontier</p>
                </div>
                <canvas id="three-canvas"></canvas>
            </div>

            <div class="bento-item min-h-[300px] md:col-span-2 lg:col-span-2 lg:row-span-2 flex flex-col justify-center scroll-animate" style="transition-delay: 100ms;">
                <div class="space-y-4">
                    <h2 class="text-3xl md:text-4xl accent-color scramble-text" data-scramble-radius="50" data-scramble-duration="1.2" data-scramble-speed="0.5" data-scramble-chars=".:">SYSTEM.ID</h2>
                    <p class="text-sm md:text-base text-gray-300 leading-relaxed scramble-text" style="word-break: keep-all; overflow-wrap: break-word; hyphens: none;">Student & future-focused entrepreneur exploring the intersections of AI, new tech, and science. I'm an introvert who finds clarity in code and complexity. My goal is to build something that matters.</p>
                    <div class="age-counter">
                        <p>Current Age: <span class="age-value" id="live-age">0.000000000</span> years</p>
                        <div class="age-progress-bar">
                            <div class="age-progress"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="bento-item min-h-[200px] md:col-span-1 lg:col-span-3 scroll-animate" style="transition-delay: 200ms;">
                <h2 class="text-3xl md:text-4xl accent-color mb-4">SKILLSET.EXE</h2>
                <div class="flex flex-wrap gap-2 md:gap-3 skills-container">
                    <span class="skill-tag text-sm md:text-base lg:text-lg px-3 md:px-4 py-1.5 md:py-2 rounded-md"><span>Python</span></span>
                    <span class="skill-tag text-sm md:text-base lg:text-lg px-3 md:px-4 py-1.5 md:py-2 rounded-md"><span>JavaScript</span></span>
                    <span class="skill-tag text-sm md:text-base lg:text-lg px-3 md:px-4 py-1.5 md:py-2 rounded-md"><span>AI Concepts</span></span>
                    <span class="skill-tag text-sm md:text-base lg:text-lg px-3 md:px-4 py-1.5 md:py-2 rounded-md"><span>New Tech</span></span>
                    <span class="skill-tag text-sm md:text-base lg:text-lg px-3 md:px-4 py-1.5 md:py-2 rounded-md"><span>Science</span></span>
                </div>
            </div>

            <div class="bento-item min-h-[200px] md:col-span-1 lg:col-span-3 flex flex-col items-center justify-center text-center scroll-animate" style="transition-delay: 300ms;">
                <h2 class="text-3xl md:text-4xl accent-color mb-4">CONTACT.CMD</h2>
                <p class="mb-6 text-sm md:text-base text-gray-400">Connect with me on Discord.</p>
                <div class="relative">
                    <button id="discord-button" class="brutalist-btn text-base md:text-xl">
                        ID: appuzlota
                    </button>
                    <span id="copy-feedback" class="absolute -bottom-8 left-1/2 -translate-x-1/2 bg-blue-500 text-white text-xs font-bold px-2 py-1 rounded-md opacity-0 transition-all duration-300 whitespace-nowrap">COPIED</span>
                </div>
            </div>

        </div>
    </main>
    
    <footer class="text-center text-gray-600 font-mono text-xs md:text-sm py-8 mt-6">
        <p>&copy; 2025 appuzlota // All systems operational.</p>
    </footer>

    <style>
        /* Typewriter Effect */
        .typewriter {
            overflow: hidden;
            white-space: nowrap;
            animation: typing 3s steps(40, end);
        }

        @keyframes typing {
            from { width: 0 }
            to { width: 100% }
        }

        /* Blinking Status */
        .blink {
            animation: blink-animation 1s infinite;
        }

        @keyframes blink-animation {
            0%, 50% { opacity: 1; }
            51%, 100% { opacity: 0.3; }
        }

        /* Glitch effect for main title */
        h1[data-text] {
            position: relative;
        }

        h1[data-text]::before,
        h1[data-text]::after {
            content: attr(data-text);
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            opacity: 0;
        }

        h1[data-text]:hover::before {
            animation: glitch-1 0.3s infinite;
            color: #FF00FF;
            z-index: -1;
            opacity: 0.8;
        }

        h1[data-text]:hover::after {
            animation: glitch-2 0.3s infinite;
            color: #00FFFF;
            z-index: -2;
            opacity: 0.8;
        }

        @keyframes glitch-1 {
            0% { clip-path: inset(40% 0 61% 0); transform: translate(-2px, -2px); }
            20% { clip-path: inset(92% 0 1% 0); transform: translate(2px, 2px); }
            40% { clip-path: inset(43% 0 1% 0); transform: translate(-2px, 2px); }
            60% { clip-path: inset(25% 0 58% 0); transform: translate(2px, -2px); }
            80% { clip-path: inset(54% 0 7% 0); transform: translate(-2px, 2px); }
            100% { clip-path: inset(58% 0 43% 0); transform: translate(2px, -2px); }
        }

        @keyframes glitch-2 {
            0% { clip-path: inset(25% 0 58% 0); transform: translate(2px, 2px); }
            20% { clip-path: inset(54% 0 7% 0); transform: translate(-2px, -2px); }
            40% { clip-path: inset(58% 0 43% 0); transform: translate(2px, -2px); }
            60% { clip-path: inset(40% 0 61% 0); transform: translate(-2px, 2px); }
            80% { clip-path: inset(92% 0 1% 0); transform: translate(2px, -2px); }
            100% { clip-path: inset(43% 0 1% 0); transform: translate(-2px, 2px); }
        }
    </style>

    <script>
        document.addEventListener('DOMContentLoaded', function () {
            
            // --- Caching DOM Elements for Performance ---
            const loader = document.querySelector('.loader');
            const cursor = document.querySelector('.cursor');
            const cursorFollower = document.querySelector('.cursor-follower');
            const noiseBg = document.querySelector('.noise-bg');
            const particlesContainer = document.getElementById('particles-container');
            const bentoItems = document.querySelectorAll('.bento-item');
            const hoverElements = document.querySelectorAll('button, a, .skill-tag, .scramble-text');
            const ageElement = document.getElementById('live-age');
            const ageProgressBar = document.querySelector('.age-progress');
            const discordButton = document.getElementById('discord-button');
            const copyFeedback = document.getElementById('copy-feedback');
            const skillTags = document.querySelectorAll('.skill-tag');

            // --- Performance optimization: Central Animation Loop using requestAnimationFrame ---
            let rafId = null;
            const animations = new Set();
            
            function runAnimations(timestamp) {
                animations.forEach(fn => fn(timestamp));
                rafId = requestAnimationFrame(runAnimations);
            }
            
            // --- Hide Loader ---
            window.addEventListener('load', () => {
                setTimeout(() => {
                    loader.classList.add('hidden');
                }, 500);
            });

            // --- Optimized Custom Cursor ---
            let mouseX = 0, mouseY = 0;
            let cursorX = 0, cursorY = 0;
            let followerX = 0, followerY = 0;

            document.addEventListener('mousemove', (e) => {
                // Update mouse position directly. The animation function will smooth it out.
                mouseX = e.clientX;
                mouseY = e.clientY;
            });

            function animateCursor() {
                // Use linear interpolation (lerp) for smooth following
                cursorX += (mouseX - cursorX) * 0.5;
                cursorY += (mouseY - cursorY) * 0.5;
                cursor.style.transform = `translate(${cursorX - 10}px, ${cursorY - 10}px)`;

                followerX += (mouseX - followerX) * 0.1;
                followerY += (mouseY - followerY) * 0.1;
                cursorFollower.style.transform = `translate(${followerX - 20}px, ${followerY - 20}px)`;
            }
            animations.add(animateCursor);

            // Cursor hover effects
            hoverElements.forEach(el => {
                el.addEventListener('mouseenter', () => cursor.classList.add('hover'));
                el.addEventListener('mouseleave', () => cursor.classList.remove('hover'));
            });

            // --- Optimized Mouse Gradient Effect ---
            let lastGradientX = 0;
            let lastGradientY = 0;
            function animateGradient() {
                const currentX = (mouseX / window.innerWidth) * 100;
                const currentY = (mouseY / window.innerHeight) * 100;

                // Only update if the change is significant enough, reduces unnecessary style changes
                if (Math.abs(currentX - lastGradientX) > 0.1 || Math.abs(currentY - lastGradientY) > 0.1) {
                    noiseBg.style.setProperty('--mouse-x', `${currentX}%`);
                    noiseBg.style.setProperty('--mouse-y', `${currentY}%`);
                    lastGradientX = currentX;
                    lastGradientY = currentY;
                }
            }
            animations.add(animateGradient);


            // --- Optimized Particle System ---
            const maxParticles = 20;
            let activeParticles = 0;
            
            function createParticle(x, y) {
                if (activeParticles >= maxParticles) return;
                
                const particle = document.createElement('div');
                particle.className = 'particle';
                particle.style.left = `${x}px`;
                particle.style.top = `${y}px`;
                
                const size = Math.random() * 4 + 2;
                particle.style.width = `${size}px`;
                particle.style.height = `${size}px`;
                particle.style.background = '#00AFFF';
                particle.style.borderRadius = '50%';
                particle.style.boxShadow = `0 0 ${size * 2}px rgba(0, 175, 255, 0.5)`;
                
                particlesContainer.appendChild(particle);
                activeParticles++;
                
                requestAnimationFrame(() => {
                    particle.classList.add('active');
                });
                
                setTimeout(() => {
                    particle.remove();
                    activeParticles--;
                }, 3000);
            }

            let particleThrottle = false;
            document.addEventListener('mousemove', (e) => {
                if (!particleThrottle) {
                    if (Math.random() > 0.8) {
                        createParticle(e.clientX, e.clientY);
                    }
                    particleThrottle = true;
                    setTimeout(() => { particleThrottle = false; }, 200);
                }
            });

            // --- Bento Item Magnetic Hover Effect ---
            bentoItems.forEach(item => {
                item.classList.add('bg-black/60', 'border', 'border-gray-800', 'rounded-lg', 'p-6', 'relative', 'overflow-hidden', 'backdrop-blur-sm');
                
                item.addEventListener('mousemove', (e) => {
                    const rect = item.getBoundingClientRect();
                    const x = e.clientX - rect.left;
                    const y = e.clientY - rect.top;
                    const centerX = rect.width / 2;
                    const centerY = rect.height / 2;
                    const deltaX = (x - centerX) / centerX;
                    const deltaY = (y - centerY) / centerY;
                    
                    // Use RAF to apply the transform for smoother rendering
                    requestAnimationFrame(() => {
                        item.style.transform = `perspective(1000px) rotateY(${deltaX * 5}deg) rotateX(${-deltaY * 5}deg) translateZ(10px)`;
                        item.style.borderColor = '#00AFFF';
                    });
                });
                
                item.addEventListener('mouseleave', () => {
                    requestAnimationFrame(() => {
                        item.style.transform = '';
                        item.style.borderColor = 'rgb(31 41 55 / 1)';
                    });
                });
            });

            // --- Live Age Counter ---
            const birthDate = new Date('2010-01-29T19:10:00');
            const msInYear = 365.25 * 24 * 60 * 60 * 1000;
            
            function updateAge() {
                const ageInMs = new Date() - birthDate;
                const ageInYears = ageInMs / msInYear;
                const yearProgress = (ageInYears % 1) * 100;
                
                ageElement.textContent = ageInYears.toFixed(9);
                ageProgressBar.style.width = `${yearProgress}%`;
            }
            animations.add(updateAge);

            /*
             * ===================================================================
             * HIGHLY OPTIMIZED Scramble Text Animation
             * Key Change: Pre-calculates character positions to avoid calling
             * getBoundingClientRect() in the mousemove event, which is the
             * main cause of lag.
             * ===================================================================
             */
            class ScrambleText {
                constructor(element) {
                    this.element = element;
                    this.originalText = element.textContent;
                    this.radius = parseFloat(element.dataset.scrambleRadius) || 50;
                    this.speed = parseFloat(element.dataset.scrambleSpeed) || 0.5;
                    this.scrambleChars = element.dataset.scrambleChars || '!<>-_\\/[]{}—=+*^?#________';
                    this.chars = [];
                    this.charPositions = []; // OPTIMIZATION: To store character positions
                    this.isAnimating = false;
                    this.animationFrame = null;
                    this.init();
                }

                init() {
                    this.element.innerHTML = '';
                    for (let i = 0; i < this.originalText.length; i++) {
                        const char = this.originalText[i];
                        const span = document.createElement('span');
                        span.className = 'char';
                        span.textContent = char;
                        this.element.appendChild(span);
                        this.chars.push({
                            element: span,
                            original: char,
                            isSpace: char === ' ',
                            isAnimating: false,
                            progress: 0,
                            targetProgress: 0,
                            lastScrambleTime: 0
                        });
                    }
                    // OPTIMIZATION: Calculate positions once initially
                    this.cacheCharPositions();

                    this.element.addEventListener('mouseenter', this.handleEnter.bind(this));
                    this.element.addEventListener('mousemove', this.handleMove.bind(this));
                    this.element.addEventListener('mouseleave', this.handleLeave.bind(this));
                    
                    // OPTIMIZATION: Recalculate on resize
                    let resizeTimeout;
                    window.addEventListener('resize', () => {
                        clearTimeout(resizeTimeout);
                        resizeTimeout = setTimeout(() => this.cacheCharPositions(), 100);
                    });
                }
                
                // OPTIMIZATION: This function calculates all character positions at once.
                cacheCharPositions() {
                    this.charPositions = this.chars.map(char => {
                        const rect = char.element.getBoundingClientRect();
                        return {
                            x: rect.left + rect.width / 2,
                            y: rect.top + rect.height / 2
                        };
                    });
                }

                handleEnter() {
                    if (!this.isAnimating) {
                        this.isAnimating = true;
                        this.animate();
                    }
                }
                
                // OPTIMIZATION: This function now uses the cached positions, making it extremely fast.
                handleMove(e) {
                    this.chars.forEach((char, index) => {
                        const pos = this.charPositions[index];
                        if (!pos) return;

                        const dx = e.clientX - pos.x;
                        const dy = e.clientY - pos.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);

                        char.targetProgress = distance < this.radius ? 1 - (distance / this.radius) : 0;
                    });
                }

                handleLeave() {
                    this.chars.forEach(char => {
                        char.targetProgress = 0;
                    });
                }

                animate() {
                    if (!this.isAnimating) return;
                    
                    const currentTime = Date.now();
                    let hasActiveChars = false;

                    this.chars.forEach(char => {
                        char.progress += (char.targetProgress - char.progress) * 0.15;

                        if (char.progress < 0.01) {
                            if (char.isAnimating) {
                                char.element.textContent = char.original;
                                char.element.classList.remove('scrambling');
                                char.isAnimating = false;
                            }
                            return;
                        }

                        hasActiveChars = true;
                        if (!char.isSpace) {
                            if (!char.isAnimating) {
                                char.element.classList.add('scrambling');
                                char.isAnimating = true;
                            }
                            if (currentTime - char.lastScrambleTime > 50) {
                                if (Math.random() < char.progress * this.speed) {
                                    char.element.textContent = this.scrambleChars[Math.floor(Math.random() * this.scrambleChars.length)];
                                } else {
                                    char.element.textContent = char.original;
                                }
                                char.lastScrambleTime = currentTime;
                            }
                        }
                    });

                    if (!hasActiveChars) {
                        this.isAnimating = false;
                        cancelAnimationFrame(this.animationFrame);
                        this.animationFrame = null;
                    } else {
                        this.animationFrame = requestAnimationFrame(this.animate.bind(this));
                    }
                }
            }
            
            document.querySelectorAll('.scramble-text').forEach(el => new ScrambleText(el));

            // --- Optimized 3D Crystal Animation ---
            const canvasContainer = document.querySelector('#three-canvas').parentElement;
            const canvas = document.getElementById('three-canvas');
            if (canvas && canvasContainer) {
                const scene = new THREE.Scene();
                const camera = new THREE.PerspectiveCamera(75, canvasContainer.clientWidth / canvasContainer.clientHeight, 0.1, 1000);
                const renderer = new THREE.WebGLRenderer({ canvas, alpha: true, antialias: false, powerPreference: "high-performance" });
                renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));

                const crystalGroup = new THREE.Group();
                scene.add(crystalGroup);

                const coreMaterial = new THREE.MeshBasicMaterial({ color: 0x00AFFF, wireframe: true, transparent: true, opacity: 0.8 });
                const coreGeometry = new THREE.IcosahedronGeometry(1.5, 0);
                const coreCrystal = new THREE.Mesh(coreGeometry, coreMaterial);
                crystalGroup.add(coreCrystal);

                const orbitingCrystals = [];
                const orbitMaterial = new THREE.MeshBasicMaterial({ color: 0x00AFFF, wireframe: true, transparent: true, opacity: 0.6 });
                for (let i = 0; i < 5; i++) {
                    const size = 0.3 + Math.random() * 0.3;
                    const geometry = new THREE.TetrahedronGeometry(size, 0);
                    const crystal = new THREE.Mesh(geometry, orbitMaterial);
                    const angle = (i / 5) * Math.PI * 2;
                    const radius = 2.5;
                    crystal.position.set(Math.cos(angle) * radius, (Math.random() - 0.5) * 2, Math.sin(angle) * radius);
                    crystal.userData = { angle, radius, speed: 0.5 + Math.random() * 0.5, yOffset: crystal.position.y };
                    orbitingCrystals.push(crystal);
                    crystalGroup.add(crystal);
                }

                camera.position.z = 7;
                
                let targetRotationX = 0, targetRotationY = 0;
                document.addEventListener('mousemove', (event) => {
                    targetRotationX = (-(event.clientY / window.innerHeight) * 2 + 1) * 0.5;
                    targetRotationY = ((event.clientX / window.innerWidth) * 2 - 1) * 0.5;
                }, { passive: true });

                let lastTime = 0;
                function animate3D(currentTime) {
                    if (currentTime - lastTime < 33) { // Cap at ~30fps
                        requestAnimationFrame(animate3D);
                        return;
                    }
                    lastTime = currentTime;
                    
                    const time = currentTime * 0.001;
                    
                    coreCrystal.rotation.x += 0.001;
                    coreCrystal.rotation.y += 0.002;
                    
                    orbitingCrystals.forEach((crystal, index) => {
                        const userData = crystal.userData;
                        userData.angle += userData.speed * 0.01;
                        crystal.position.x = Math.cos(userData.angle) * userData.radius;
                        crystal.position.z = Math.sin(userData.angle) * userData.radius;
                        crystal.position.y = userData.yOffset + Math.sin(time + index) * 0.3;
                        crystal.rotation.x += 0.01;
                        crystal.rotation.y += 0.01;
                    });
                    
                    crystalGroup.rotation.x += (targetRotationX - crystalGroup.rotation.x) * 0.05;
                    crystalGroup.rotation.y += (targetRotationY - crystalGroup.rotation.y) * 0.05;
                    
                    renderer.render(scene, camera);
                    requestAnimationFrame(animate3D);
                }
                
                function handleResize() {
                    const width = canvasContainer.clientWidth;
                    const height = canvasContainer.clientHeight;
                    camera.aspect = width / height;
                    camera.updateProjectionMatrix();
                    renderer.setSize(width, height);
                }
                
                let resizeTimeout;
                window.addEventListener('resize', () => {
                    clearTimeout(resizeTimeout);
                    resizeTimeout = setTimeout(handleResize, 100);
                });
                
                handleResize();
                animate3D(0);
            }

            // --- Scroll Animations ---
            const observer = new IntersectionObserver((entries) => {
                entries.forEach(entry => {
                    if (entry.isIntersecting) {
                        requestAnimationFrame(() => {
                            entry.target.classList.add('is-visible');
                            if (entry.target.querySelector('.skills-container')) {
                                entry.target.querySelector('.skills-container').classList.add('skills-visible');
                            }
                        });
                        observer.unobserve(entry.target);
                    }
                });
            }, { threshold: 0.1, rootMargin: '0px 0px -50px 0px' });
            document.querySelectorAll('.scroll-animate').forEach(el => observer.observe(el));

            // --- Discord Button ---
            discordButton.addEventListener('click', async () => {
                try {
                    await navigator.clipboard.writeText('appuzlota');
                    copyFeedback.style.opacity = '1';
                    copyFeedback.style.transform = 'translate(-50%, -10px)';
                    setTimeout(() => {
                        copyFeedback.style.opacity = '0';
                        copyFeedback.style.transform = 'translate(-50%, 0)';
                    }, 2000);
                } catch (err) {
                    console.error('Failed to copy: ', err);
                }
            });

            // --- Magnetic Skill Tags ---
            skillTags.forEach(tag => {
                tag.addEventListener('mousemove', (e) => {
                    const rect = tag.getBoundingClientRect();
                    const deltaX = (e.clientX - rect.left - rect.width / 2) / (rect.width / 2);
                    const deltaY = (e.clientY - rect.top - rect.height / 2) / (rect.height / 2);
                    requestAnimationFrame(() => {
                        tag.style.transform = `translate(${deltaX * 3}px, ${deltaY * 3}px) translateY(-2px)`;
                    });
                });
                tag.addEventListener('mouseleave', () => {
                    requestAnimationFrame(() => {
                        tag.style.transform = '';
                    });
                });
            });

            // --- Start the main animation loop ---
            runAnimations();

            // --- Accessibility and Performance: Pause animations when tab is hidden ---
            document.addEventListener('visibilitychange', () => {
                if (document.hidden) {
                    if (rafId) {
                        cancelAnimationFrame(rafId);
                        rafId = null;
                    }
                } else if (!rafId) {
                    runAnimations();
                }
            });
            
             // Cleanup on exit
            window.addEventListener('beforeunload', () => {
                if (rafId) cancelAnimationFrame(rafId);
                animations.clear();
            });
        });

        // --- Additional CSS for new features and optimizations ---
        const style = document.createElement('style');
        style.textContent = `
            /* Ripple Effect */
            .ripple {
                position: absolute; border-radius: 50%; background: rgba(255, 255, 255, 0.6);
                transform: scale(0); animation: ripple-animation 0.6s ease-out; pointer-events: none;
            }
            @keyframes ripple-animation { to { transform: scale(4); opacity: 0; } }
            
            /* Reduced Motion Support */
            @media (prefers-reduced-motion: reduce) {
                * {
                    animation-duration: 0.01ms !important;
                    animation-iteration-count: 1 !important;
                    transition-duration: 0.01ms !important;
                    scroll-behavior: auto !important;
                }
                .noise-bg, .particle, #three-canvas { display: none; }
            }

            /* Keyboard Navigation */
            body:has(*:focus-visible) *:focus-visible {
                outline: 2px solid #00AFFF;
                outline-offset: 2px;
            }

            /* Touch Device Optimizations */
            .touch-device .cursor, .touch-device .cursor-follower { display: none; }
            
            /* Low-end device optimizations */
            @media (max-width: 768px), (max-height: 600px) {
                 #three-canvas, .particle { display: none; }
            }
        `;
        document.head.appendChild(style);
    </script>
</body>
</html>
